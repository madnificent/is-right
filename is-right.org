#+BABEL: :tangle no :cache no :session yes :results silent :no-expand yes :noweb yes :exports code :padline yes
#+startup: hideblocks overview fninline
is-right unit test system

is-right is an aid for unit test systems which makes verifying that a particular function abides the same contracts as before easier.

* general explenation
this section describes is-right and its current implementation

** conceptual idea
the simplest way of verifying the correctnes of a function, is by checking whether or not they are correct in the repl.  you can easily execute the function and see if the result is the expected result.  in case the result is the expected result, it should be trivial to create a unit test from this case.  if a function is correct, the system can enter this solution as a fixed solution, a solution to which the function should always adhere.

the unit tests which are created this way, should be written to a file corresponding to the package in which the function is defined.  as such the system can automatically store the tests in a sane location.  the tests can be described as lisp sexps and should - to some extent - be user-edible.  the latter should not be seen as a priority.

as such the user can enter a form, which will be transformed to code that needs to be executed when the function is ran.  right now, is-right is implemented as a test system in itself, though the generic idea is that the system can be implemented on top of a better unit test system as well.  the latter is probably an end-solution which should be targetted soon.

** construction
the system consists of a unit test system and an implementation which allows one to add tests to the system.

*** unit test system
the unit test system is built around some very basic building blocks.  for starters, we assume that tests are always available as executable lists in memory.  eval is being used as the mechanism of choice to execute the tests.  secondly the system assumes that all tests which need to return non-nil are written within an is macro.  these are the terms that is-right checks.

from a test execution perspective, the tests are grouped in three execution groups:
- all tests :: this group entails all tests which have been recorded.  for each package, the tests noted for each function, are executed.
- one package :: a group entailing all tests for a particular package, makes it easy to test the most important dependent tests.
- one function :: runs all tests belonging to a particular function.  makes it easy te test if a specific function is still working.

an extention which runs the tests of the current package and all loaded packages which use this package (until top-level packages have been found).  this is, however, not in the scope for the current system.

*** test entry system
the test entry system allows the user to specify that a particular execution of the function is currently correct.  is-right will then execute the function, note the result of the function and jot down the correctnes of the test.  for this execution, two test entry mechanisms have been provided.  the first executes a functional test for which nothing needs to be set up.  this is the simplest form, it's executed by the macro is-right in which the function call is placed.  there's no further special syntax, as long as you don't depend on setting up stuff externally.  the second form allows one to specify the creation of the environment in which the function should be executed.  this can be done by using the macro is-right*.  one must then use the is macro to indicate a valid match.

* implementation
this chapter contains the impplementation of is-right.

** administration
as for each lisp library, packages need to be created and an asdf definition is wanted.  furthermore the structure of the lisp file(s) is specified in this section.  all that is defined in the administration section.

*** asdf system
:PROPERTIES:
:tangle: is-right.asd
:END:
unless otherwise specified, the verification system is published under the MIT license.  we don't explicitly supply it, but assume the license is known by its name.

#+begin_src lisp
  (asdf:defsystem :is-right
    :name "common lisp unit test helpers"
    :author "Aad Versteden <madnificent@gmail.com>"
    :version "0.0.1"
    :maintainer "Aad Versteden <madnificent@gmail.com>"
    :licence "MIT"
    :description "unit test system which helps the user write tests based on the current implementation of specific functions."
    :depends-on (cl-ppcre)
    :serial t
    :components ((:file "packages")
                 (:file "is-right")))
#+end_src

*** package description
:PROPERTIES:
:tangle: packages.lisp
:END:
the asdf definition describes a separate file which will contain the package.  from the earlier description, it is known which parts should be described in the package.

#+begin_src lisp
  (defpackage :is-right
    (:use :common-lisp)
    (:export :is :same :is-right :is-right*
             :test :rm-tests
             :test-all :test-package :test-function
             :failed-test :failed-is-test :failed-same-test
             :mk-package-test-file
             :print-mock-object :print-form :print-subform
             :make-print-form :make-mock-print-form))
#+end_src

*** lisp source
:PROPERTIES:
:tangle: is-right.lisp
:END:
all lisp sources are currently contained within a single file.  this section describes how that file is constructed.

for starters, everything is specified in the is-right package.

#+begin_src lisp
  (in-package :is-right)

  <<unit-test-system>>

  <<test-additions>>
  
#+end_src

** unit test system
:PROPERTIES:
:noweb-ref: unit-test-system
:END:
the unit test system is the basis for this testing framework.  it stores all tests in memory and allows for the added definition of these tests.  there's currently no support for removing a specific test-case from the image, as it's assumed that this will not occur often, if at all.

*** test storage
currently all tests are stored as plists.  the plists are first divided by package and later divided by the tested function.

#+begin_src lisp

  (defvar *unit-tests* nil
    "contains a plist of packages.  the contents of the plist is a plist of functions.  the plist of functions has a regular lisp list as values, each containing a test.")

#+end_src

*** support functions
this section describes various support functions which are used throughout the code

**** getting function or symbol information
whenever we try to find, store or execute the tests for a specific function or symbol, we need to distill the needed information from the symbol.  currently we need to figure out both the symbol representing the function and the symbol which represents the package of the symbol or function.

this is a relatively simple problem, but it gives rise to a host of problems, as functions don't necessarily have (their) symbol connected to them.  it is advised to use symbols, instead of functions as this is the only portable solution.  yet still, we try to catch this and figure out the correct execution when we can do so.

#+begin_src lisp
  
  (defun distill-function-information (function-symbol)
    "tries to distill the package and the symbol representing the function from <function-symbol> this is only guaranteed to work when function-symbol is a symbol, yet we try to solve it non-portably, when function-symbol is a function as well.
  
     unless an error is signaled, this function returns two values.  the first value is a symbol representing the function, the second value is the package of the symbol."
    (setf function-symbol
          (cond ((functionp function-symbol)
                 (let ((symbol
                        (nth-value 2 (function-lambda-expression function-symbol))))
                   (when (or (null symbol)
                             (not (symbolp symbol)))
                     (error "Test based on function ~A for which we can't find a related symbol." function-symbol))
                   symbol))
                ((symbolp function-symbol)
                 function-symbol)
                (T (error "Test based on function ~A, which can't be translated to a related symbol." function-symbol))))
    (values function-symbol
            (symbol-package function-symbol)))
  
#+end_src

*** test accessors
the tests need to be stored when they are defined and they need to be retrievable.  the tests are stored when calling the function #'test .

**** adding tests
in order to add a test, the test-form is added to the respective plist. the plists are walked based on the information from distill-function-information.

#+begin_src lisp
  
  (defun test (function test-form)
    "test-function is the function version to add tests to the is-right test framework.
     function is expected to be the function which will be tested.  only the symbol of the function is supported portably.
     test-form is the form which will be executed as a test for the given function."
    (multiple-value-bind (function-symbol package)
        (distill-function-information function)
      (push test-form
            (getf (getf *unit-tests* package)
                  function-symbol))))
  
#+end_src

**** finding tests for a function
in order to find a test, the plists are walked based on the information from distill-function-information.

#+begin_src lisp
  
  (defun get-tests-for-function (function)
    "returns a list of all tests which belong to function."
    (multiple-value-bind (symbol package)
        (distill-function-information function)
      (getf (getf *unit-tests* package)
            symbol)))
  
#+end_src

**** finding tests for a given package
the tests for a specific package are returned as a plist which, for each function for which there are registered tests, a list containing the forms which need to be checked is made available.

#+begin_src lisp
  
  (defun get-tests-for-package (package)
    "returns the tests for the given package."
    (when (symbolp package)
      (setf package (find-package package)))
    (getf *unit-tests* package))
  
#+end_src

**** removing tests for a function or package
when a file containing tests is read, all tests for that package are removed.  a function is created which removes the tests when a package is supplied.  if the function is supplied with a symbol, the tests for the function resembling that symbol are removed.

#+begin_src lisp
  
  (defun rm-tests (function-or-package)
    "removes the tests for the given package or function"
    (if (symbolp function-or-package)
        (multiple-value-bind (function-symbol package)
            (distill-function-information function-or-package)
          (setf (getf (getf *unit-tests* package)
                      function-symbol)
                nil))
        (setf (getf *unit-tests* function-or-package) nil)))
  
#+end_src

*** running tests
the execution of tests has various components.  there's the execution component which executes a single test, a search component which searches for the tests which need to be executed and a logging component which informs the user about the execution of the tests.  each of these components are described here.

the first section describes how a single test can be executed.  on top of this, a system is constructed which can execute multiple tests.  further down the road the search for the tests to execute is described.  the execution of these new groups is trivial, aside from the logging which needs to occur when a test either fails or succeeds.

**** executing a single test
in order to execute the test, we need to figure out how to specify that a test can be executed and how an is construct should behave.  what do we do when the test fails, how do we know the test failed?  this is clearly a solid block of knowledge which interconnects quite rigidly.

in order to make the system work, we introduce a new error-class which is to be executed when a test fails to run.  this error can then be catched in order to display the error output for the given test.

#+begin_src lisp
  
  (define-condition failed-test (error)
    ((test :initarg :test
           :reader test-form)
     (explenation :initarg :explenation
                  :reader explenation)
     (complete-test :initarg :complete-test
                    :reader complete-test))
    (:documentation "error which is thrown when a test fails to execute"))
  
  (defmethod print-object ((object failed-test) stream)
    (print-unreadable-object (object stream)
      (format stream "~& Explenation: ~A~& Test: ~A~& Complete test: ~A~&" (explenation object) (test-form object) (complete-test object))))
  
  (define-condition failed-is-test (failed-test)
    ((explenation :initform "a form containing 'is failed to return a non-nil value."))
    (:documentation "error which is thrown when an is-test failed to return a non-nil value."))
  
#+end_src

in order to figure out what has been executed, the execution of the test itself will need to supply information to us.  the test which we are currently executing needs to be known, a special variable which will be shadowed in our execution is created for this matter.

#+begin_src lisp
  
  (defvar *complete-test* nil
    "contains the complete form which is currently being tested")
  
#+end_src

as the test requires both the complete test, as the form on which the test failed, the 'is form cannot be defined as a regular function call.  a macro is created which transforms the is construction into something that throws an error when it fails.

#+begin_src lisp
  
  (defmacro is (form)
    "verifies that form returns a non-nil value.

     the implementation of this macro is shadowed in is-right*"
    `(unless ,form
       (error 'failed-is-test
              :test (quote ,form)
              :complete-test *complete-test*)))
  
#+end_src

with this 'is macro defined, we've reached the need to execute a particular test.  the execution of the test needs to setup the *complete-test* variable and it needs to evaluate the form itself.

#+begin_src lisp
  
  (defun execute-test (test-form)
    "executes a single test"
    (let ((*complete-test* test-form))
      (eval test-form)))

#+end_src

**** adding test verification constructions
with the if construction defined, it's relatively simple to construct other checks based on the same structure.  these new checks amount to a simpler, clearer definition of the tests themselves.

***** same
the same construction tests for equality between its first and its second form.

as a first step a new error is constructed which will manage the error-reporting towards the end-user.

#+begin_src lisp
    
  (define-condition failed-same-test (failed-test)
    ((explenation :initform "a form containing 'same failed to return both the same values.  check received value and expected value for the resulting forms.")
     (received-value :initarg :received
                     :reader received-value)
     (expected-value :initarg :expected
                     :reader expected-value)))
  
  (defmethod print-object ((err failed-same-test) stream)
    (print-unreadable-object (err stream)
      (format stream "~& Explenation: ~A~& Test: ~A~& Complete test: ~A~& Received: ~A~& Expected: ~A~&" (explenation err) (test-form err) (complete-test err) (received-value err) (expected-value err))))
  
#+end_src

with this error defined, it's simple to create the 'same macro, in the likes of the 'is macro.

#+begin_src lisp
    
  (defmacro same (expected-value form)
    "verifies that form returns a value which appears to be equal to the expected value."
    (let ((g-returned-value (gensym))
          (g-expected-value (gensym)))
      `(let ((,g-returned-value ,form)
             (,g-expected-value ,expected-value))
         (unless (equal ,g-returned-value ,g-expected-value)
           (error 'failed-same-test
                  :test (quote ,form)
                  :complete-test *complete-test*
                  :expected ,g-expected-value
                  :received ,g-returned-value))
         ,g-returned-value)))
  
#+end_src

**** executing groups of tests
the execution of a group of tests can be done on three accounts
- one function
- one package
- all packages

each of these build on the execution of the previous.  in order to figure out what the system is currently doing, output is generated to indicate the status of the tests which are being ran.

***** one function
the most basic of these forms is the execution of one one function.  when executing the tests of a single function, the function name, followed by the amount of tests available for the specific function is displayed.  furthermore a user-visible function is created which searches all tests for a specific function and executes them.

let's visit the execution of the tests for a particular function first.  the function which needs to perform the tests receives a symbol representing the function which is being tested and the tests which need to be executed.  the execution of a test is performed by execute-test, displaying the output is done by this function

#+begin_src lisp
  
  (defun test-function* (symbol &rest tests)
    "runs all tests in <tests> for the function denoted by symbol <symbol>"
    (format T "~&~A (~A) ~t" symbol (length tests))
    (force-output)
    (dolist (test tests)
      (restart-case (progn
                      (execute-test test)
                      (format T "."))
        (accept-test-failure ()
          (format T "X")))
      (force-output)))
  
#+end_src

the execution of the tests for a particular function now relies on finding the tests and the name of the function, and calling test-function* based on that.

#+begin_src lisp
  
  (defun test-function (function)
    "tests the given function"
    (let ((function-symbol (distill-function-information function)))
      (apply #'test-function*
             function-symbol
             (get-tests-for-function function-symbol))))
  
#+end_src

***** testing a package 
the testing of a complete package requires us to test each function in the package.  we take a similar approach as the previous system.  in this approach the function which displays the execution of the package is shown first and the other functions are shown later on.

#+begin_src lisp
  
  (defun test-package* (package &rest function-plist)
    "tests all the given functions in the plist <function-plist> and reports output for the tests, given that they come from <package>."
    (format T "~&Running tests in ~A (~A)~&" package
            (loop for (name tests . rest) on function-plist by #'cddr
               sum (length tests)))
    (format T "~&------------------------------~&")
    (loop for (name tests . rest) on function-plist by #'cddr
       do (apply #'test-function* name tests)))
  
#+end_src

the execution of the tests for a particular package are now constructed by calling the currently defined function with all the tests in the package.

#+begin_src lisp
  
  (defun test-package (package)
    "tests each function in <package> and lists the execution."
    (unless (packagep package)
      (setf package (find-package package)))
    (apply #'test-package*
           package
           (get-tests-for-package package)))
  
#+end_src

***** testing all packages
this is a trivial test, given the previous tests.  a function to call this programatically is not given, as there's no use for calling this internally.

#+begin_src lisp
  
  (defun test-all ()
    "runs the tests for each monitored package"
    (format T "~&TESTING ALL PACKAGES (~A)~&"
            (loop for (package fplist . rest) on *unit-tests* by #'cddr
               sum (loop for (function tests . rest) on fplist by #'cddr
                      sum (length tests))))
    (format T "~&==============================~&")
    (loop for (package fplist . rest) on *unit-tests* by #'cddr
       do (progn
            (format T "~&~%")
            (apply #'test-package* package fplist)
            (format T "~&~%==============================~&"))))
  
#+end_src

** test addition system
:PROPERTIES:
:noweb-ref: test-additions
:END:
various ways exist to add tests to getright.  the most basic way to add tests is by using 'test.  in order to make testing of functions easier, the is-right construction is introduced, this construction asserts that a certain function call is correct.  is-right and is-right* are two macro's which will take care of this.

*** conceptual idea
in its basic concept is-right adds tests to the current set of tests under the assumption that their current implementation is correct.  for this to happen the system builds a test based on the current implementation of the function, and adds the test to a separate file.  this makes the creation of tests relatively simple.

for this to work, the construction is split in various parts.  the first part makes it possible to assert that a function is currently implemented correctly for a specific function call.  verification of this is done by creating a function which takes a form and converts the form to a test case.

secondly a system is defined which specifies where tests should be stored.  this is an extensible system which must be informed about the locations where test cases should be stored in and retrieved from.

lastly, the constructions of the previous two sections are distilled into a working format for the end-user.  later on, this will be extended to display a nicer implementation.

*** writable result translate
in this section the results of various functions will be calculated.  the results of these objects can't always be written to the stream by using write, therefore we introduce a new system for writing objects when they need to be used in test-cases.

note: some study time has come round to ensure that Common Lisp doesn't provide an architecture for this usage.  there is an equivalent system for constructing forms which can be /read/ correctly, but that doesn't constitute forms which need to abide evaluatability.  as such a small new system is introduced for this usecase.

**** conceptual
we need to introduce a new read system and it would be preferred if we'd be able to introduce this system in a way that's reusable to some extent.  for this reason a multi-layered system is introduced.  each layer introduces a broader, yet less ideas solution to the problem.  the layers themselves are constructed in a class hierarchy, which should allow them to be extended in other systems which need printing.

- print-mock-object :: print-mock-object is the most applicable method.  the method tries to print the object in a way suited for mocking.  the object representing the printing through print-mock-object receives the object which must make the printing work as well.
- print-form :: print-form is the most usable broad level object.  it returns a list which, when evaluated, returns an object equivalent to the object given to it.  it doesn't allow for fine-grained control over the objects which are to be printed and as such, it is more generic.
- print-object :: as a last resort, we back out to print-object.  this basically means that the current system doesn't know how to print the given object and that we're doing a best effort to read it anyways.

for later to become historical reasons the name printing is used erroneously here.  when we print an object, we return an s-expression that, when evaluated, will yield an object with the properties which have been talked about.

**** implementation approach
in order to make all this work seamlessly something is needed which expresses how the thing ought to have been printed if more information was available.  this could be done by creating an extensive object oriented system.  on the other hand, we don't want to burden the user with all sorts of uninteresting oddities, we want the user to have a clean interface in which he can specify how the objects ought to be printed.  for this reason the implementation of the system itself is layered in two systems as well.  the lower-level system dirigates the control flow through each of the print-functions, the higher-level system provides implementations of each of the plotting levels.  in this system the existence of a more applicable system gains absolute preference over the existence of an implementation of a less ideal method.

the methods which the user implements should never be called by the user himself.  when the user needs to print a form, he needs to call the /print-subform/ which will make sure that the order in which each of the forms had been called, is still correct.  for instance, if the upper-level printing mechanism isn't interested in printing mock objects, then it will only try to use print-form and print-object.  adding such flexibility makes it easier to print objects for various causes later on (thus promoting reusability if this library would split off from is-right.


**** user visible generic functions
as described earlier, the user has various generic methods at his disposal which he should use to print the objects.  some of these generic functions are for him to implement, a single other is for him to use.  for each printing option, a regular function will be used to control the printing itself, that regular function is defined later on, as syntactic sugar.  this section also provides the generic definition of /print-subform/, which will be used when the user implements one of the other methods.

#+begin_src lisp
  
  (defgeneric print-subform (object)
    (:documentation "when you use this system and you need to print an instance which isn't directly related to yourself, you should call the print-subform method on that object.  this will ensure that the correct order of execution is used."))
  
  (defgeneric print-mock-object (function object)
    (:documentation "prints a mock object for the given function.  this allows you to load only a specific aspect of the object for the given function."))
  
  (defgeneric print-form (object)
    (:documentation "adds an s-expression, which, when evaluated, will yield an equivalent object."))
    
#+end_src

**** backend classes
the backend consists of various classes, each representing a way to print objects generically.  through the use of subclassing and method specialisation, the order of, and exact method calls for, the various levels can be specified.

let's define the classes for each of the three currently defined print levels first.

#+begin_src lisp
  
  (defclass base-printlevel ()
    ()
    (:documentation "base class for the printing of instances."))
  
  (defclass form-printlevel (base-printlevel)
    ()
    (:documentation "prints the objects so reading/evaluating them will result in an equivalent object."))
  
  (defclass mock-printlevel (form-printlevel)
    ((test-function-symbol :initform nil
                           :initarg :test-function-symbol
                           :reader test-function-symbol))
    (:documentation "prints the instance so that reading/evaluating them will result in an object which has all the needed similarities for the given test."))
  
#+end_src

these levels will be passed to the various functions by the use of a parameter, called *current-printlevel*.

#+begin_src lisp
  
  (defparameter *current-printlevel* nil
    "variable which is shadowed when printing occurs, so print-subform can call the correct toplevel function.")
  
#+end_src

in case a certain level of printing has been implemented for a superclass of the current class, but shouldn't be implemented for the current class, an error indicating this is thrown to indicate this.  this error, and the implementation for each of the defined methods is specified here.

#+begin_src lisp
  
  (define-condition unsupported-printlevel (error)
    ()
    (:documentation "indicates that the printlevel was not supported for the given objects"))
  
  (defmethod print-mock-object (function object)
    (error 'unsupported-printlevel))
  (defmethod print-form (object)
    (error 'unsupported-printlevel))
  
#+end_src

furthermore, we need a single generic function which dictates how each level ought to be printed, based on the current printlevel.

#+begin_src lisp
  
  (defgeneric call-printlevel (printlevel object)
    (:documentation "prints the object in the given printlevel"))
  
  (defmethod call-printlevel ((printlevel base-printlevel) object)
    object)
  
  (defmethod call-printlevel :around ((printlevel form-printlevel) object)
    (handler-case
        (print-form object)
      (unsupported-printlevel ()
        (call-next-method))))
  
  (defmethod call-printlevel :around ((printlevel mock-printlevel) object)
    (handler-case
        (print-mock-object (test-function-symbol printlevel)
                           object)
      (unsupported-printlevel ()
        (call-next-method))))
  
#+end_src

**** how to start the printing
with this system in place, we still need to define how one can start printing the objects.  for each of the currently defined levels, a function will be introduced to indicate the start of the printing.  each of these functions calls a generic function to handle the setup of the printing environment.  aside from this, the standard (and only) implementation of the #'print-subform generic function is implemented.

#+begin_src lisp
  
  (defun boot-printing (printlevel object)
    "boots the printing of any currently known printlevel.  the printlevel-specific functions use this."
    (let ((*current-printlevel* printlevel))
      (call-printlevel printlevel object)))
  
  (defun make-print-form (object)
    "prints the object as a form through the print-form generic function."
    (boot-printing (make-instance 'form-printlevel)
                   object))
  
  (defun make-mock-print-form (object function)
    "prints the object as a mock object through the print-mock-object generic function"
    (boot-printing (make-instance 'mock-printlevel
                                  :test-function-symbol function)
                   object))
  
#+end_src

the printing of subforms is still to be implemented.  this is a relatively simple function though, as we have access to the global printlevel object.

#+begin_src lisp
  
  (defmethod print-subform (object)
    (boot-printing *current-printlevel* object))
  
#+end_src

**** implement basic functions
lists don't respond correctly to being printed through print-object, as the list needs to be quoted.  the same issue holds for sequences and such.

#+begin_src lisp
  
  (defun pure-list-p (cons-cell)
    (when (listp cons-cell)
      (loop for (a . b) on cons-cell
         unless (listp b) return nil
         collect a)))
  
  (defmethod print-form ((cell cons))
    (if (pure-list-p cell)
        (cons 'list (loop for item in cell collect (print-subform item)))
        `(cons ,(print-subform (car cell))
               ,(print-subform (cdr cell)))))
  
  (defmethod print-form ((seq sequence))
    ;; TODO: make this correct, you want everything of the normal array, but not the element-type
    (let ((new-array
           (make-array (array-dimensions seq))))
      (loop for i from 0 below (length seq)
         do (setf (elt new-array i)
                  (print-subform (elt seq i))))
      `(quote ,new-array)))
  
  (defmethod print-form ((symbol symbol))
    `(quote ,symbol))
  
#+end_src

*** assert function calls
when a function call is currently correct, we may want to prefer to add it to the system.  in order to add this, the function must be executed and its value must be computed.  by using the name of the function and the value which it currently has, we can distill the needed information.

**** simplistic implementation
in its most simplistic implementation we receive the function that is to be tested.  furthermore a functioncall is provided to indicate the test function itself.

#+begin_src lisp
  
  (defun make-test-for-function-execution (function form)
    "creates a test for the function execution of form"
    (let ((execution-value (eval form)))
      `(test ',function (same ,(make-mock-print-form execution-value function) ,form))))
  
#+end_src

**** implementation with automatic symbol definition
the symbol of the function which is being called can be verified quite simply in case the function is called immediately.  as this is the support which is-right provides, we create a function for this.

#+begin_src lisp
  
  (defun make-get-right-test (form &optional form-when-test-overridden)
    "returns a test-form for the test which can be constructed from the current execution of form"
    (let* ((function-form (if form-when-test-overridden
                              form-when-test-overridden
                              form))
           (function-symbol (if form-when-test-overridden
                                form
                                (first function-form))))
      (values (make-test-for-function-execution function-symbol function-form)
              function-symbol)))
  
#+end_src

in case get-right* is being used, we need to figure out which form is being tested by walking over the constructions of the form.  the form which is being tested is wrapped in a form with first name 'is.

be warned though, this construction isn't exactly correct.  it (wrongly) assumes that is will not be used for other forms.  furthermore it assumes that there's only a single is test in the form, which again, might be erroneous.

#+begin_src lisp
  
  (defun make-get-right*-test (form &optional form-when-test-overridden)
    (let* ((function-form (if form-when-test-overridden
                              form-when-test-overridden
                              form))
           (function-symbol (when form-when-test-overridden
                              form)))
      (let ((execution-values nil))
        (labels ((get-function-values (form)
                   (if (listp form)
                       (if (eq (first form) 'is)
                           `(push (make-mock-print-form
                                   ,(second form)
                                   ',(or function-symbol
                                         (if (listp (second form))
                                             (first (second form))
                                             (second form))))
                                  execution-values)
                           (loop for expression in form
                              collect (get-function-values expression)))
                       form)))
          (setf execution-values
                (reverse (eval `(let ((execution-values nil))
                                  ,(get-function-values function-form)
                                  execution-values))))
          (labels ((walk-get-right-form (form)
                     (if (eq (first form) 'is)
                         ;; translate if-form
                         (let ((function-form (second form)))
                           (setf function-symbol
                                 (or function-symbol (first function-form)))
                           `(same ,(pop execution-values) ,function-form))
                         ;; walk other forms
                         (loop for expression in form
                            collect (if (listp expression)
                                        (walk-get-right-form expression)
                                        expression)))))
            (let ((new-form (walk-get-right-form function-form)))
              (values `(test ',function-symbol
                             (quote ,new-form))
                      function-symbol)))))))
  
#+end_src

*** file registry for tests
as the forms which need to be executed to perform the tests on a certain function can be created from the function call in itself, it's important that the test cases can also be stored.  as many functions may need to be stored, the system created here stores the set of test cases in a per-package manner.

for each package, a file can be defined.  each test which is constructed on a function which resides in that package, will be stored in that file.  this way, the tests for a certain package are discoverable by the user and can be edited with relative ease.

**** finding and specifying package test paths
if we're going to remember where tests need to be placed, we need to store that information somewhere.  this is described in this section.

we store the packages and their related variables in a plist, as it provides the simplest storage at the moment.
#+begin_src lisp
  
  (defvar *package-files* nil
    "a plist which contains the package as key and for each package for which the location where the tests need to be stored is known, the path to that file.")
  
#+end_src

as the files where the tests reside will need to be get and set, functions are introduced to update the *package-files* variable.

#+begin_src lisp
  
  (defun packagetests-file (package)
    "setfable place for the file in which the package tests are defined, or nil if such a file is not known."
    (unless (packagep package)
      (setf package (find-package package)))
    (getf *package-files* package))
  
  (defun (setf packagetests-file) (file package)
    (unless (packagep package)
      (setf package (find-package package)))
    (setf (getf *package-files* package)
          file))
  
#+end_src

**** ensuring test storage exists
when we discover a new test file and want to read in those sources, we need to ensure that the file exists.  if the file doesn't exist, we create the file and setup some standard information about it.

#+begin_src lisp
  
  (defun ensure-packagetest-file (file package-symbol)
    "checks whether or not file exists. if the file doesn't exist an initial declaration is added which will clear the known tests from the current system when interpreted."
    (setf (packagetests-file package-symbol) file)
    (unless (probe-file file)
      (with-open-file (out file :direction :output)
        (let ((*package* (find-package package-symbol)))
          (write `(cl:in-package ,package-symbol))
          (write `(is-right:rm-tests (cl:find-package ',package-symbol)) :stream out :readably t)
          (format out "~&~%")))))
  
#+end_src

**** extending the tests in storage
when new tests are added, they should be added to the test storage as well.  this basically means that we must find the file in which the package is described and that we must append the test to that file.  the function assumes that the symbol representing the function is known, thus making it easy to find the filename to write to.  in case no file is found an error is thrown.

#+begin_src lisp
  
  (defun add-test-to-file (function form)
    "adds <form>, which is a complete test for function <function>, to the files which are known."
    (let ((package (nth-value 1 (distill-function-information function))))
      (with-open-file (out (packagetests-file package)
                          :direction :output
                          :if-exists :append)
        (let ((*package* package))
          (write form :stream out :readably t)
          (format out "~&~%")))))
  
#+end_src


*** spray some sugar
this section describes functions which have been introduced to make it easier on the end-user to use this system.

**** specifying package test files
on various occasions will the user specify the files in which tests for a particular class of functions ought to be placed.  this is done through the mk-package-test-file function.

#+begin_src lisp
  
  (defun mk-package-test-file (package-symbol file)
    "ensures that a package test file for package-symbol exists and is located in file.  furthermore ensures that the system knows the file for further additions.  it also reads the contents of the file, so the tests can be interpreted."
    (ensure-packagetest-file file package-symbol)
    (setf (packagetests-file package-symbol) file)
    (load file))
  
#+end_src

**** automatically adding tests
is-right allows you to add tests to the system and to the package file.  simply calling is-right will ensure that the information is available in there.

#+begin_src lisp
  
  (defmacro is-right (form &optional form-when-symbol-overridden)
    "adds the test for form to the set of tests for the given function"
    (multiple-value-bind (test func)
        (make-get-right-test form form-when-symbol-overridden)
      (add-test-to-file func test)
      test))
  
#+end_src

is-right* is similar, but better.  it allows for the definition of tests in a specific environment.  the setup is extremely similar.

#+begin_src lisp
  
  (defmacro is-right* (form &optional form-when-symbol-overridden)
    (multiple-value-bind (test func)
        (make-get-right*-test form form-when-symbol-overridden)
      (add-test-to-file func test)
      test))
  
#+end_src

* emacs integration
:PROPERTIES:
:tangle: is-right.el
:END:
one of the goals was to integrate is-right nicely within emacs.  the following elisp command picks the last code to exectue and renders a sexp which adds the function through a regular is-right construction.  this construction can manually be edited in order to form an is-right* command with an is-construction nested in between.

#+begin_src elisp
  
  (defun mk-is-right ()
    "inserts the last executed repl command in the buffer"
    (interactive)
    (insert (concat "(is-right:is-right " (first slime-repl-input-history) ")")))
  
#+end_src

* testing is-right in is-right
:PROPERTIES:
:tangle: is-right-tests.lisp
:END:
is-right can be tested within itself, this is rather cool!

** managing the test sources
for this we create an is-right-tests package and add the code in the same file.

#+begin_src lisp
  
  (cl:defpackage :is-right-tests
    (:use :cl :is-right :asdf))
  
  (cl:in-package :is-right-tests)
  
#+end_src

** storing tests for is-right
the tests for is-right are stored in a file named is-right-packagetests.lisp , relative to the is-right system.  this is the second thing we configure for is-right-tests

#+begin_src lisp
  
  (mk-package-test-file :is-right
                        (asdf:system-relative-pathname :is-right "is-right-packagetests.lisp"))
  
#+end_src
